package com.irctc_backend.irctc.service;

import com.irctc_backend.irctc.annotation.ExecutionTime;
import com.irctc_backend.irctc.config.PaymentGatewayConfig;
import com.irctc_backend.irctc.dto.PaymentCallbackRequest;
import com.irctc_backend.irctc.dto.PaymentRequest;
import com.irctc_backend.irctc.dto.PaymentResponse;
import com.irctc_backend.irctc.entity.Booking;
import com.irctc_backend.irctc.entity.Payment;
import com.irctc_backend.irctc.repository.BookingRepository;
import com.irctc_backend.irctc.repository.PaymentRepository;
import com.irctc_backend.irctc.util.LoggingUtil;
import com.razorpay.Order;
import com.razorpay.RazorpayClient;
import com.razorpay.RazorpayException;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Payment Service
 * 
 * This service handles all payment-related operations including payment initiation,
 * processing, verification, and refunds. It integrates with Razorpay payment gateway
 * for secure payment processing.
 * 
 * @author IRCTC Development Team
 * @version 1.0.0
 */
@Service
@Transactional
public class PaymentService {
    
    private static final Logger logger = LoggerFactory.getLogger(PaymentService.class);
    
    @Autowired
    private PaymentRepository paymentRepository;
    
    @Autowired
    private BookingRepository bookingRepository;
    
    @Autowired
    private PaymentGatewayConfig paymentGatewayConfig;
    
    @Autowired
    private NotificationService notificationService;
    
    private RazorpayClient razorpayClient;
    
    /**
     * Initialize Razorpay client
     */
    private void initializeRazorpayClient() {
        if (razorpayClient == null) {
            try {
                razorpayClient = paymentGatewayConfig.razorpayClient();
            } catch (Exception e) {
                logger.error("Failed to initialize Razorpay client: {}", e.getMessage());
            }
        }
    }
    
    /**
     * Initiate payment for a booking
     * 
     * @param paymentRequest Payment request details
     * @return PaymentResponse with payment details
     */
    @ExecutionTime("Initiate Payment")
    @CacheEvict(value = {"bookings", "payments"}, allEntries = true)
    public PaymentResponse initiatePayment(PaymentRequest paymentRequest) {
        long startTime = System.currentTimeMillis();
        String requestId = LoggingUtil.generateRequestId();
        
        try {
            logger.info("Initiating payment for booking ID: {}, amount: {}", 
                       paymentRequest.getBookingId(), paymentRequest.getAmount());
            
            // Validate booking exists and is not already paid
            Booking booking = bookingRepository.findById(paymentRequest.getBookingId())
                .orElseThrow(() -> new RuntimeException("Booking not found"));
            
            if (paymentRepository.existsSuccessfulPaymentForBooking(booking.getId())) {
                throw new RuntimeException("Booking is already paid");
            }
            
            // Create payment record
            Payment payment = createPaymentRecord(paymentRequest, booking);
            payment = paymentRepository.save(payment);
            
            // Initialize Razorpay client
            initializeRazorpayClient();
            
            if (razorpayClient == null) {
                logger.warn("Razorpay client not available, creating mock payment");
                return createMockPaymentResponse(payment);
            }
            
            // Create Razorpay order
            Order razorpayOrder = createRazorpayOrder(paymentRequest, payment);
            
            // Update payment with gateway order ID
            payment.setGatewayOrderId(razorpayOrder.get("id"));
            payment.setGatewayResponse(razorpayOrder.toString());
            payment = paymentRepository.save(payment);
            
            // Create response
            PaymentResponse response = PaymentResponse.initiated(
                payment.getId(),
                payment.getTransactionId(),
                payment.getAmount(),
                payment.getGatewayOrderId(),
                getPaymentUrl(payment.getGatewayOrderId()),
                null // QR code will be generated by frontend
            );
            
            response.setPaymentMethod(payment.getPaymentMethod());
            response.setCurrency(payment.getCurrency());
            
            logger.info("Payment initiated successfully. Payment ID: {}, Transaction ID: {}", 
                       payment.getId(), payment.getTransactionId());
            
            return response;
            
        } catch (Exception e) {
            logger.error("Failed to initiate payment: {}", e.getMessage(), e);
            throw new RuntimeException("Payment initiation failed: " + e.getMessage());
        }
    }
    
    /**
     * Process payment callback from gateway
     * 
     * @param callbackRequest Callback request from payment gateway
     * @return PaymentResponse with updated status
     */
    @ExecutionTime("Process Payment Callback")
    @CacheEvict(value = {"bookings", "payments"}, allEntries = true)
    public PaymentResponse processPaymentCallback(PaymentCallbackRequest callbackRequest) {
        long startTime = System.currentTimeMillis();
        String requestId = LoggingUtil.generateRequestId();
        
        try {
            logger.info("Processing payment callback for order ID: {}", callbackRequest.getOrderId());
            
            // Find payment by gateway order ID
            Payment payment = paymentRepository.findByGatewayOrderId(callbackRequest.getOrderId())
                .orElseThrow(() -> new RuntimeException("Payment not found"));
            
            // Verify signature if available
            if (callbackRequest.getSignature() != null && !verifySignature(callbackRequest)) {
                logger.error("Invalid payment signature for order ID: {}", callbackRequest.getOrderId());
                payment.setStatus(Payment.PaymentStatus.FAILED);
                payment.setFailureReason("Invalid signature");
                paymentRepository.save(payment);
                return PaymentResponse.failure(payment.getId(), payment.getTransactionId(),
                    payment.getAmount(), payment.getStatus(), "Invalid signature");
            }
            
            // Update payment status
            if (callbackRequest.isSuccessful()) {
                payment.setStatus(Payment.PaymentStatus.COMPLETED);
                payment.setPaymentDate(LocalDateTime.now());
                payment.setGatewayPaymentId(callbackRequest.getPaymentId());
                payment.setGatewaySignature(callbackRequest.getSignature());
                
                // Update booking payment status
                Booking booking = payment.getBooking();
                booking.setPaymentStatus(Booking.PaymentStatus.COMPLETED);
                bookingRepository.save(booking);
                
                // Send notification
                notificationService.publishPaymentCompletedEvent(booking);
                
                logger.info("Payment completed successfully. Payment ID: {}, Amount: {}", 
                           payment.getId(), payment.getAmount());
                
                return PaymentResponse.success(payment.getId(), payment.getTransactionId(),
                    payment.getAmount(), payment.getStatus(), "Payment completed successfully");
                
            } else {
                payment.setStatus(Payment.PaymentStatus.FAILED);
                payment.setFailureReason(callbackRequest.getErrorMessage());
                payment.setRetryCount(payment.getRetryCount() + 1);
                
                if (payment.getRetryCount() < payment.getMaxRetryAttempts()) {
                    payment.setNextRetryAt(LocalDateTime.now().plusMinutes(5));
                }
                
                paymentRepository.save(payment);
                
                logger.warn("Payment failed. Payment ID: {}, Reason: {}", 
                           payment.getId(), callbackRequest.getErrorMessage());
                
                return PaymentResponse.failure(payment.getId(), payment.getTransactionId(),
                    payment.getAmount(), payment.getStatus(), callbackRequest.getErrorMessage());
            }
            
        } catch (Exception e) {
            logger.error("Failed to process payment callback: {}", e.getMessage(), e);
            throw new RuntimeException("Payment callback processing failed: " + e.getMessage());
        }
    }
    
    /**
     * Get payment status
     * 
     * @param paymentId Payment ID
     * @return PaymentResponse with current status
     */
    public PaymentResponse getPaymentStatus(Long paymentId) {
        Payment payment = paymentRepository.findById(paymentId)
            .orElseThrow(() -> new RuntimeException("Payment not found"));
        
        return PaymentResponse.success(payment.getId(), payment.getTransactionId(),
            payment.getAmount(), payment.getStatus(), "Payment status retrieved");
    }
    
    /**
     * Retry failed payment
     * 
     * @param paymentId Payment ID
     * @return PaymentResponse with retry details
     */
    @ExecutionTime("Retry Payment")
    public PaymentResponse retryPayment(Long paymentId) {
        Payment payment = paymentRepository.findById(paymentId)
            .orElseThrow(() -> new RuntimeException("Payment not found"));
        
        if (payment.getStatus() != Payment.PaymentStatus.FAILED) {
            throw new RuntimeException("Only failed payments can be retried");
        }
        
        if (payment.getRetryCount() >= payment.getMaxRetryAttempts()) {
            throw new RuntimeException("Maximum retry attempts exceeded");
        }
        
        // Reset payment for retry
        payment.setStatus(Payment.PaymentStatus.PENDING);
        payment.setFailureReason(null);
        payment.setRetryCount(payment.getRetryCount() + 1);
        payment.setNextRetryAt(null);
        payment = paymentRepository.save(payment);
        
        // Create new payment request and initiate
        PaymentRequest retryRequest = createRetryPaymentRequest(payment);
        return initiatePayment(retryRequest);
    }
    
    /**
     * Process refund for a payment
     * 
     * @param paymentId Payment ID
     * @param refundAmount Refund amount
     * @param refundReason Refund reason
     * @return PaymentResponse with refund details
     */
    @ExecutionTime("Process Refund")
    public PaymentResponse processRefund(Long paymentId, BigDecimal refundAmount, String refundReason) {
        Payment payment = paymentRepository.findById(paymentId)
            .orElseThrow(() -> new RuntimeException("Payment not found"));
        
        if (payment.getStatus() != Payment.PaymentStatus.COMPLETED) {
            throw new RuntimeException("Only completed payments can be refunded");
        }
        
        if (refundAmount.compareTo(payment.getAmount()) > 0) {
            throw new RuntimeException("Refund amount cannot exceed payment amount");
        }
        
        // Process refund through gateway
        try {
            initializeRazorpayClient();
            
            if (razorpayClient != null) {
                // Create refund through Razorpay
                JSONObject refundRequest = new JSONObject();
                refundRequest.put("amount", refundAmount.multiply(new BigDecimal("100")).intValue()); // Convert to paise
                refundRequest.put("notes", refundReason);
                
                com.razorpay.Refund refund = razorpayClient.payments.refund(payment.getGatewayPaymentId(), refundRequest);
                
                // Update payment with refund details
                payment.setRefundAmount(refundAmount);
                payment.setRefundDate(LocalDateTime.now());
                payment.setRefundReason(refundReason);
                
                if (refundAmount.compareTo(payment.getAmount()) == 0) {
                    payment.setStatus(Payment.PaymentStatus.REFUNDED);
                } else {
                    payment.setStatus(Payment.PaymentStatus.PARTIALLY_REFUNDED);
                }
                
                paymentRepository.save(payment);
                
                logger.info("Refund processed successfully. Payment ID: {}, Refund Amount: {}", 
                           paymentId, refundAmount);
                
                return PaymentResponse.success(payment.getId(), payment.getTransactionId(),
                    refundAmount, payment.getStatus(), "Refund processed successfully");
            } else {
                // Mock refund for testing
                payment.setRefundAmount(refundAmount);
                payment.setRefundDate(LocalDateTime.now());
                payment.setRefundReason(refundReason);
                payment.setStatus(Payment.PaymentStatus.REFUNDED);
                paymentRepository.save(payment);
                
                return PaymentResponse.success(payment.getId(), payment.getTransactionId(),
                    refundAmount, payment.getStatus(), "Refund processed successfully (mock)");
            }
            
        } catch (Exception e) {
            logger.error("Failed to process refund: {}", e.getMessage(), e);
            throw new RuntimeException("Refund processing failed: " + e.getMessage());
        }
    }
    
    /**
     * Get payments for a booking
     * 
     * @param bookingId Booking ID
     * @return List of payments
     */
    public List<Payment> getPaymentsForBooking(Long bookingId) {
        return paymentRepository.findByBookingIdAndStatus(bookingId, null);
    }
    
    /**
     * Create payment record
     */
    private Payment createPaymentRecord(PaymentRequest request, Booking booking) {
        Payment payment = new Payment();
        payment.setBooking(booking);
        payment.setTransactionId(UUID.randomUUID().toString());
        payment.setAmount(request.getAmount());
        payment.setPaymentMethod(request.getPaymentMethod());
        payment.setCurrency(request.getCurrency());
        payment.setStatus(Payment.PaymentStatus.PENDING);
        payment.setRetryCount(0);
        payment.setMaxRetryAttempts(paymentGatewayConfig.getRetryAttempts());
        return payment;
    }
    
    /**
     * Create Razorpay order
     */
    private Order createRazorpayOrder(PaymentRequest request, Payment payment) throws RazorpayException {
        JSONObject orderRequest = new JSONObject();
        orderRequest.put("amount", request.getAmount().multiply(new BigDecimal("100")).intValue()); // Convert to paise
        orderRequest.put("currency", request.getCurrency());
        orderRequest.put("receipt", payment.getTransactionId());
        orderRequest.put("notes", request.getFormattedDescription());
        
        return razorpayClient.orders.create(orderRequest);
    }
    
    /**
     * Verify payment signature
     */
    private boolean verifySignature(PaymentCallbackRequest callbackRequest) {
        try {
            String webhookSecret = paymentGatewayConfig.getRazorpayWebhookSecret();
            if (webhookSecret == null || webhookSecret.isEmpty()) {
                logger.warn("Webhook secret not configured, skipping signature verification");
                return true; // Allow in development
            }
            
            // Implement signature verification logic here
            // This is a simplified version - in production, use proper HMAC verification
            return callbackRequest.getSignature() != null && !callbackRequest.getSignature().isEmpty();
            
        } catch (Exception e) {
            logger.error("Error verifying signature: {}", e.getMessage());
            return false;
        }
    }
    
    /**
     * Get payment URL for redirection
     */
    private String getPaymentUrl(String orderId) {
        return String.format("https://checkout.razorpay.com/v1/checkout.js?payment_id=%s", orderId);
    }
    
    /**
     * Create mock payment response for testing
     */
    private PaymentResponse createMockPaymentResponse(Payment payment) {
        return PaymentResponse.initiated(
            payment.getId(),
            payment.getTransactionId(),
            payment.getAmount(),
            "mock_order_" + payment.getId(),
            "mock_payment_url",
            null
        );
    }
    
    /**
     * Create retry payment request
     */
    private PaymentRequest createRetryPaymentRequest(Payment payment) {
        PaymentRequest request = new PaymentRequest();
        request.setBookingId(payment.getBooking().getId());
        request.setAmount(payment.getAmount());
        request.setPaymentMethod(payment.getPaymentMethod());
        request.setCurrency(payment.getCurrency());
        request.setCustomerName(payment.getBooking().getUser().getFirstName() + " " + 
                               payment.getBooking().getUser().getLastName());
        request.setCustomerEmail(payment.getBooking().getUser().getEmail());
        request.setCustomerPhone(payment.getBooking().getUser().getPhoneNumber());
        return request;
    }
}
